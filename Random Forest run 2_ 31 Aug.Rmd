---
title: "Rhod RandomForest 2"
author: "Madan K Suwal"
date: "31 August 2016"
output: html_document
---
    
### Random Forest for Rhododendron 
#### R. lowndesii with Rhododendron pseudo-absence
### **Copy and relocated files from working directory**
```{r}
pre.df <- read.csv("W:/Rhododendron data/Rh_3_spp_Presence_Elev_2500_to_4200.csv")
abs.df <- read.csv("W:/Rhododendron data/Rhodendron_absence_900_to_5000.csv")
pseu.df<- read.csv("W:/Rhododendron data/Random_pseudoabsence_elev_1000_to_5500.csv")
latt.df<- read.csv("W:/Rhododendron data/lattice3km_current.csv")
latt70s.df<-read.csv("W:/Rhododendron data/Lattice3km 2070s.csv")
```
    
```{r}
setwd("W:/Rhododendron data/R outputs")
```    
These data set lacks Presence/Absence column, i.e. 1/0     
Add with 1/0 column   
```{r}
pre.df$PA<-1 ;  pre.df[1:2,]
abs.df$PA<-0 ;  abs.df[1:2,]
pseu.df$PA<-0 ; pseu.df[1:2,]
```   
check data sets, remove extra columns      
```{r}
pre.df <- pre.df[,-c(4, 25, 26)]
pre.df[1:2,]
abs.df <- abs.df[,-c(4, 25, 26)]
abs.df[1:2,]
pseu.df <- pseu.df[,-c(4, 25, 26)]
pseu.df[1:2,]
latt.df <- latt.df[,-c(24, 25)]
latt.df[1:2,]
latt70s.df <- latt70s.df[,-c(24, 25)]
latt70s.df[1:2,]
```   
Check dataframe size   
```{r}
dim(pre.df); dim(pseu.df); dim(abs.df); dim(latt.df); dim(latt70s.df)
```    
Extarct presence points by SPECIES
```{r}
pre.lepi<- subset(pre.df, species=="lepidotum" )
pre.lown<- subset(pre.df, species=="lowndesii" )
pre.cown<- subset(pre.df, species=="cowanianum" )
```
#### FILE TO WORK ON     
Change the file for every species and pseudoabsence accordingly    
```{r}
PFi  = pre.lown  # presence file
AFi  = abs.df   # Absence file
```    
Partition train and test for *presennce*         
```{r}
set.seed(4437) # to obtain same result all the time
sample.idP <- sample (2, nrow (PFi), replace =TRUE, prob = c(0.7, 0.3))
rh.trainP  <- PFi [sample.idP == 1, ]  # training presence
rh.testP   <- PFi [sample.idP == 2, ]  # test presence
```      
Partition train and test for *pseudoabsence*    
```{r}
set.seed(4436)
sample.idA <- sample (2, nrow (AFi), replace =TRUE, prob = c(0.7, 0.3))
rh.trainA  <- AFi [sample.idA == 1, ]  # training pseudoabsence
rh.testA   <- AFi [sample.idA == 2, ]  # test pseudoabsence
```    
Combining train and test data    
```{r}
rbind(rh.trainP, rh.trainA)-> rh.train  # For Training 
rbind(rh.testP,  rh.testA) -> rh.test   # For Test
rbind(rh.train,  rh.test)  -> rh.df     # Training and Test combined
dim(rh.df)
```    
Check Presence and Pseudoabsence ratio in Train and Test data set   
```{r}
table(rh.train$PA)
table(rh.test$PA)
```   
Load library       
```{r} 
library(randomForest)
```
##### Run RandomForest model    
```{r}
names(rh.train)
rh.rf<-randomForest(x=rh.train[4:25], y=as.factor (rh.train$PA), 
                    ntree=2000,  importance = TRUE)
print(rh.rf)      
plot (rh.rf)      
```      
      
2000 decision trees or a forest has been built using the Random Forest algorithm based learning. We can plot the error rate across decision trees. The plot seems to indicate that after 500 decision trees, there is not a significant reduction in error rate      

##### Variable Importance plot   
```{r}
varImpPlot(rh.rf, sort = TRUE, main = "Variable Importance", n.var=10)      
```      
      
Variable Importance Table    
```{r}
var.imp<- data.frame (importance(rh.rf, type= 2))
var.imp$Variables <- row.names(var.imp)
var.imp[order (var.imp$MeanDecreaseGini, decreasing = TRUE), ]->ImpVarList
print(ImpVarList)
```    
To measure the accuracy of the Random Forest model. Some of the other model performance statistics are KS, Lift Chart and ROC Curve    

Predicting response variables    
```{r}
rh.train$predicted.resp<- predict(rh.rf, rh.train[4:25])
```
Confusion matrix: function from "caret" package can be used for creating confusion matrix based on actual response variable and predicted value.   
Load libraries
```{r, message=FALSE, include=FALSE}
library(e1071)
library(caret)
```
    
```{r}
confusionMatrix(data= rh.train$predicted.resp, 
                reference= rh.train$PA, positive = '1')->confu.train
confu.train
```   
The "positive" represents true case such as 1 for 1/0, Yes for Yes/No, Ture for T/F. It has accuracy of 99.18%, which is fantastic. Now we can predict response for the validation sample and calculate model accuracy for the sample.   
   
Predicting to test data set   
Predicting response variable   
```{r}
rh.test[1:2,]
rh.test$predicted.resp<- predict(rh.rf, rh.test[4:25], OOB=TRUE, type="response")
```   
Create confusion matrix    
```{r}
confusionMatrix(data=rh.test$predicted.resp, 
                reference = rh.test$PA, positive = '1')->confu.test
confu.test
```      
    
Response curves of top variables    
```{r}
library(ggplot2)
as.vector(ImpVarList[1:10,2])->Top10Var  # Top 10 variables from RF imp list

pPA<-predict(rh.rf, rh.test, 'vote')[,2]
plotData<-lapply (Top10Var, function(x) {
  out<-data.frame(
    var=x,
    type=c(rep('Actuall', nrow(rh.test)), rep('Predicted', nrow (rh.test))),
    value=c(rh.test[,x], rh.test[,x]),
    PA=c(as.numeric(rh.test$PA), pPA)
  )
  out$value<-out$value - min(out$value) #Normalize to [0,1]
  out$value<-out$value/max (out$value)
  out
})
plotData<-do.call(rbind, plotData)
# Export Response curves
tiff(filename = "Response Curves RF top 10 var.tiff", 
     width = 5000, height = 1500, compression = "lzw", res=250)
qplot(value, PA, data=plotData, facets=type ~var, geom='smooth', span=0.5)+ theme_bw() 
dev.off()
```   
#### K-fold Corss Validation in RandomForest    
To partition the first fold
```{r}
k=5
n= floor(nrow(rh.df)/k) # n = size of each fold, and value is rounded by "floor" 
err.vect= rep (NA, k)   # store the error in this vector

i = 1
s1 = ((i-1) * n+1) # the start of the subset
s2 = (i*n)         # The end of the subset
subset = s1:s2     # the range of the subse
```
Because of round above, the end of the subset may be slightly out of range    

Next, move to the second fold:    
i = 2   
.......   
But we automate this by looping   

Load library
```{r, include=FALSE}
library(randomForest)
library(verification)
```
##### Need to loop over each of the K- folds
###### The input y-variables must be numeric to calculate the roc.area error, which RF needs in vector
store output probability in    
```{r}
OutputPre<-PFi[,c(1,2,3)]       # Extract Long/lat and Species colum
```
Predict to lattice, extracct probability and True/False   
```{r}
names(latt.df)
latt.df$PA <- 0                  # Add PA colunm to fill NAs
latt.p<- latt.df[,c(2,3)]         # Extact Long/Lat only
```
    
```{r}
names(latt70s.df)
latt70s.df$PA <- 0              # Add PA colunm to fill NAs
latt70s.p<- latt70s.df[,c(2,3)]  # Extact Long/Lat only
```
RandomForest Looping for 5 times    
```{r}
for (i in 1:k){
    s1 = ((i-1) * n+1) # the start of the subset
    s2 = (i*n)         # The end of the subset
    subset = s1:s2     # the range of the subset
    
    cv.train = rh.train[,4:26] # Train the model using this data
    cv.test = rh.test[,4:26] # test the model's performace on this data
    
    # run the random forest on the training data set, exclude on predictor variables
    fit = randomForest (x=cv.train[,-c(23)], y= as.factor (cv.train[,23]), ntree=2000)
    prediction = predict (fit, newdata= cv.test[, -c(23)], type="prob")[,2]
    # Predict to species data for threshold
    OutputPre[3+i]<- predict (fit, newdata= PFi[,4:26], type="prob")[,2]
    # Predict to Current climate lattice 
    latt.p[2+i]<- predict (fit, newdata=latt.df[,4:26], type= "prob" ) [,2]
    # Predict to Future climate lattice
    latt70s.p[2+i]<- predict (fit, newdata=latt70s.df[,4:26], type= "prob" ) [,2]
    
    # calculate the model's accurancy for the ith fold
    err.vect[i] <-   roc.area (cv.test[ , 23], prediction)$A
    #print(paste("AUC for fold", i, ":", err.vect[i]))
  }
```     
Mean error     
```{r}
print(data.frame(err.vect)) # list of AUCs from k fold
print(paste("Average AUC:", mean(err.vect)))
```
Take mean of 5 probabilities to new column    
```{r}
head(OutputPre)
OutputPre$AvgProb<- rowMeans(OutputPre[,4:8])
```
Rename columns
```{r}
library(data.table) # library for renaming colunms
setnames(OutputPre, old=c(4,5,6,7,8), new=c("prob1", "prob2", "prob3", "prob4", "prob5" ))
head(OutputPre)
```

```{r}
latt.p$AvgProb<- rowMeans(latt.p[,3:7])
setnames(latt.p, old=c(3,4,5,6,7), new=c("prob1", "prob2", "prob3", "prob4", "prob5" ))
head(latt.p)
```

```{r}
latt70s.p$AvgProb<- rowMeans(latt70s.p[,3:7])
setnames(latt70s.p, old=c(3,4,5,6,7), new=c("prob1", "prob2", "prob3", "prob4", "prob5" ))
head(latt70s.p)
```

##### For AUC calculation and plot    
Creating performance object   
```{r, include=FALSE}
library(ROCR)
```

```{r}
a.v<-as.vector(rh.rf$votes[,2]) # extract predicted '1'
perf.obj<- prediction( predictions = a.v, labels = rh.train$PA  )

# Calculate AUC
rh.AUC <- performance(perf.obj, "auc")
AUC=rh.AUC@y.values[[1]]; AUC
# Plot ROC 
rh.ROC <- performance(perf.obj, 'tpr', 'fpr')
plot(rh.ROC, main="ROC Plot", xlab=" 1 - Specificity: False Positive Rate", 
     ylab="Sensitivity: True Positive Rate", lwd=2)
abline(a=0,b=1, lty=3, lwd=2)  # Diagonal line
text(0.85,0.0, labels = paste("Average AUC:",round( mean(err.vect),3)))
```    
       
Export ROC plot     
```{r}
tiff(filename = "ROC curve_ Lepidotum with Rhodo Pseudo.tiff", 
       width = 2000, height = 1500, compression = "lzw", res=200)
plot(rh.ROC, main="ROC Plot", xlab=" 1 - Specificity: False Positive Rate", 
     ylab="Sensitivity: True Positive Rate", lwd=2)
abline(a=0,b=1, lty=3, lwd=2)  # diagonal line
text(0.85,0.0, labels = paste("Average AUC:",round( mean(err.vect),3)))
dev.off()  
```       
Export Random Forest model plot    
```{r}
tiff(filename = "Model plot.tiff", width = 2000, 
     height = 1500, compression = "lzw", res=200)
plot(rh.rf, col="black")
legend(1200, 0.21, lty=c(3, 1, 2), bty="n", 
       legend=c("Presence", "OOB", "Pseudoabsence" ))
dev.off()
# To display in HTML file
plot(rh.rf, col="black")
legend(1200, 0.21, lty=c(3, 1, 2), bty="n", 
       legend=c("Presence", "OOB", "Pseudoabsence" ))
```       
        
##### Export Variable Importance, Predicted current and future climate lattice, and K-fold AUC     
```{r}
write.csv(ImpVarList, file = "Lowndesii with Rhodo Pseudo_ Var Imp list.csv")
write.csv(latt.p,     file = "Lowndesii with Rhodo Pseudo Current Climate.csv")
write.csv(latt70s.p,  file = "Lowndesii with Rhodo Pseudo Future 2070s.csv")
write.csv(err.vect,   file = "AUC from K-fold.csv")
```
Other results to *Note*    
```{r}
print(paste("Average AUC:", mean(err.vect)))
```
   
```{r}
print (rh.rf)
confu.train
confu.test
```    
For *threshold*     
```{r}
quantile(OutputPre$AvgProb, c(0.05, 0.10)) # for Threshold
min(OutputPre$AvgProb)     # minimun presence threshold
```


#### THE END